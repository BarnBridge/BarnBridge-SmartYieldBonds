# Smart Yield

# General Architecture

We propose a system where there are 2 types of participants:

- Junior token holders
- Senior BOND holders

Junior token holders provide liquidity and buy risk from Senior bond investors. The risk in the case of Smart Yield product is the risk of variable rate annuities going down.

Investors that buy the Senior bonds (sBONDs) will have a guaranteed yield for the life of the sBOND, which will be one of the 2 main properties of the sBOND (along with TVL).

The liquidity provided by the "juniors" and the value locked in the sBONDs are invested in various DeFi lending platforms and the resulting rewards cover the guaranteed rate for senior sBONDs. Some of these rewards come in the form of governance tokens which our system will sell on Uniswap for the native token of our pool. We will consider Compound as our lending platform and DAI as our pool token.

Juniors will benefit from the extra rewards generated by DAIs locked in sBONDs by seniors in situations where the variable APY of Compound (including the COMP rewards) are higher than the weighted average guaranteed yields of current sBONDs. On the other hand, in the event of falling rewards from Compound, the returns of Juniors are diminished and if need be, their locked funds will be used to pay for the guaranteed returns of sBONDs.

In order to provide the best UX for Juniors and encourage them to participate in our Smart Yield pools, we want the system to allow them to join the pool at any time. Moreover we want the possibility of instant withdrawal of at least part of their funds, without affecting the integrity of the system and keeping the guarantees.

To do that, we have to be able to be able to calculate the profits and losses of the pool very efficiently. We do that by averaging all existing sBONDs into one weighted average sBOND with the following properties:
- Principal (DAI) locked (sum) -> ABOND.principal
- Guaranteed rewards (DAI, sum) -> ABOND.reward
- Weighted average start timestamp -> ABOND.start
- Weighted average end timestamp -> ABOND.end

### The Weighted average timestamps are calculated in the following way:

#### new sBOND added
`ABOND.start = ((ABOND.start * ABOND.reward) + (new_sBOND.start * new_sBOND.reward)) / (ABOND.reward + new_sBOND.reward)`

`ABOND.end = ((ABOND.end * ABOND.reward) + (new_sBOND.end * new_sBOND.reward)) / (ABOND.reward + new_sBOND.reward)`

`ABOND.reward += new_sBOND.reward`
`ABOND.principal += new_sBOND.principal`

#### old sBOND redeemed after maturity date,

`ABOND.start = ((ABOND.start * ABOND.reward) - (old_sBOND.start * old_sBOND.reward)) / (ABOND.reward - old_sBOND.reward)`

`ABOND.end = ((ABOND.end * ABOND.reward) - (old_sBOND.end * old_sBOND.reward)) / (ABOND.reward - old_sBOND.reward)`

`ABOND.reward -= new_sBOND.reward`
`ABOND.principal -= new_sBOND.principal`

total_duration = wa_end - wa_start
elapsed_time = block.timestamp - wa_start

The aggregate sBOND (ABOND) represents the current Senior pool and it will help us calculate the health of the Senior pool at an instant. If the rewards generated by the Senior pool so far exceed the guaranteed rewards at this time (time factor included), the extra reward can be considered profit for the junior pool (and loss if it's negative).

To keep track of profits and losses of Junior Token holders (bbcDAI, if the provider is compound), we update the exchange rate of bbcDAI to DAI before certain events (juniorDeposit, juniorWithdraw).

bbcDAI_to_DAI_ratio start at 1 and it's updated in the following way:
`bbcDAI_to_DAI_ratio = total_junior_pool_dai / total_bbcDAI_supply`

Where
```
total_junior_pool_dai = total_pool_dai - senior_dai_deposits - (ABOND.reward * MIN(elapsed_time, total_duration) / total_duration)
```

`total_pool_dai = total_dai_holdings - owed_dai`

total_pool_dai includes the unrealized DAI profits, which includes the COMP rewards given to the pool priced in DAI and periodically sold for DAI on Uniswap and added to the pool.

To prevent an arbitrage attack, the pool calculates the moving average (TBD if we use a Kalman filter) price of COMP.

![](https://i.imgur.com/umIL8gy.png)

The shaded areas are the elapsed guaranteed part of the aggregate sBOND. As discussed above, we calculate the current profit and loss of the Junior pool based on this.

In order to keep the jToken price unchanged after a new sBOND is created or when a sBOND is redeemed (the 2 events that creates a new ABOND based on the old ABOND and the respective change), the blue shaded area should be equal to the black shaded area. To do that without changing the shape of the ABOND (rate of reward per second), we can shift the whole rectangle to the left or right on the time axis to achieve g2 == g1.

`(old_ABOND.reward * (block_timestamp - old_ABOND.start) / (old_ABOND.end - old_ABOND.start)) = (new_ABOND.reward * (block_timestamp - correct_start) / (new_ABOND.end - new_ABOND.start))`

=>

`correct_start = (old_ABOND.end * new_ABOND.reward * block.timestamp + old_ABOND.start * new_ABOND.end * old_ABOND.reward - old_ABOND.start * new_ABOND.reward * block.timestamp - old_ABOND.start * new_ABOND.start * old_ABOND.reward - new_ABOND.end * old_ABOND.reward * block.timestamp + new_ABOND.start * old_ABOND.reward * block.timestamp) / (old_ABOND.end * new_ABOND.reward - old_ABOND.start * new_ABOND.reward)`

After we have `correct_start`, we shift the ABOND.start and ABOND.end with an equal amount in the same direction.

```
initial_start = ABOND.start;
ABOND.start = correct_start;
ABOND.end -= (initial_start - correct_start);
```


## Junior Deposit
Steps for deposit (in order):

- recalculate bbcDAI_to_DAI_ratio
- mint bbcDAI proportional to the new bbcDAI_to_DAI_ratio and transfer to Junior
- exchange deposited DAI to cDAI

## Senior deposit (buy BOND)
When an sBOND is created, a fixed guaranteed yield is calculated for it from on-chain data. The fixed rate is based on the moving average APY of the pool's provider, in this example Compound. We track the NET APY of Compound in a Smart Contract and calculate its moving average (or Kalman filter, TBD). In the same SC, we also track the price of COMP tokens that affect the NET APY.

`x = (cur_j - (b_p*x*n*b_t)) / (cur_tot + b_p + (b_p*x*n*b_t)) * n * m`

Where:
```
x = guaranteed_rate

cur_j = current junior liquidity = total_pool_dai - senior_dai_deposits - locked_dai - (jtokens_total_queued_for_withdrawal * bbcDAI_to_DAI_ratio)

locked_dai = MAX(0, ABOND.reward - (jtokens_queued_for_withdrawal_at_risk * bbcDAI_to_DAI_ratio))

cur_tot = current total_pool_dai, before we add the bond principal to it

b_p = bond principal

b_t = bond duration in seconds

n = NET APY

m = pool multiplier, default to 1. The BBDAO can choose to increase the multiplier to incentivize senior BOND creation and vice versa.
```

The solution is:
`x = (sqrt(4 b_p cur_j m n^2 b_t + (b_p m n^2 b_t + b_p + cur_tot)^2) - b_p m n^2 b_t - b_p - cur_tot)/(2 b_p n b_t)`

- Calculate the guaranteed rate based on above
- Add principal to aggregate sBOND
- Add guaranteed reward to aggregate sBOND
- Recalculate aggregate sBOND weighted start and end
- Shift the result ABOND to right and left (on time axis) to keep the jToken price (bbcDAI_to_DAI_ratio) unchanged
- Allocate the sBOND the the Senior
- Exchange Senior deposit DAI to cDAI
- senior_deposits += amount

## Senior withdraw (redeem sBOND)

Steps:
- Require current_timestamp > sBOND.end_timestamp
- Require sBOND.owner == Senior
- Exchange all comp on Uniswap and add cDAI to pool
- recalculate bbcDAI_to_DAI_ratio
- Substract sBOND.principal from aggregate BOND
- Substract sBOND.reward from aggregate BOND
- Recalculate aggregate sBOND weighted start and end (with sBOND removed)
- Shift the result ABOND to right and left (on time axis) to keep the jToken price (bbcDAI_to_DAI_ratio) unchanged
- Exchange enough cDAI to pay the BOND's initial DAI + guaranteed reward
- Transfer the DAI to senior
- Delete sBOND
- senior_deposits -= sBOND.principal


## Junior Initiate Withdraw
A junior is subject to Senior tranche risk. In order for a jToken holder to exit the pool, the current sBONDs need to mature. Because it is computationally intensive and gas inefficient to track each and every sBOND with each tx, we opt to use the Aggregated Bond (ABOND) as an approximation for the Senior tranche.

Steps for exit:
1st step:
- recalculate bbcDAI_to_DAI_ratio
- transfer Junior bbcDAI to pool (lock)
- queue liquidation after ABOND.end. First tx after that timestamp will trigger the liquidation (pseudocode below).

2nd step:
After the lock period has ended, the Junior can exchange the remaining bbcDAI and finish the Withdraw process:

Steps:
- send junior's liquidated DAI
- clear user lock status so Junior can deposit again


Code:

```solidity
struct Liquidation {
    uint256 amount; // in jTokens
    uint256 amount_at_risk; // in jTokens
    uint256 price; // bbcDAI_to_DAI_ratio - 0 means not triggered
}
public mapping(uint256 => Liquidation) queued_liquidations; // timestamp -> Liquidation
public uint256[] queued_liquidation_timestamps;
public uint256 last_queued_liquidation_timestamps_key; // defaults to 0

struct UserLiquidation {
    uint256 amount; // in jTokens
    uint256 amount_at_risk; // in jTokens
    uint256 timestamp;
}
public mapping(address => UserLiquidation) queued_user_liquidations;


public uint256 owed_dai = 0;
// total_pool_dai should always be dai.balanceOf(address(this)) - total_pool_dai

public uint256 jtokens_total_queued_for_withdrawal = 0;
public uint256 jtokens_queued_for_withdrawal_at_risk = 0;
// cur_j = total_pool_dai - senior_dai_deposits - locked_dai - (jtokens_total_queued_for_withdrawal * bbcDAI_to_DAI_ratio)
// locked_dai = ABOND.reward - (jtokens_queued_for_withdrawal_at_risk * bbcDAI_to_DAI_ratio)


function juniorInitiateWithdraw() {
  userJtokens = balanceOf(msg.sender);
  userJtokensAtRisk = userJtokens * (ABOND.reward / bbcDAI_to_DAI_ratio / total_bbcDAI_supply);

  // queue user's jTokens for liquidation
  Liquidation storage liquidation = queued_liquidations[ABOND.end];
  if(liquidation.amount == 0) {
    queued_liquidation_timestamps.push(ABOND.end)
  }
  liquidation.amount += userJtokens;
  liquidation.amount_at_risk += userJtokensAtRisk;

  // lock user jTokens (transfer to self), and register liquidation object for user
  transferFrom(msg.sender, address(this), userJtokens);
  jtokens_total_queued_for_withdrawal += userJtokens;
  jtokens_queued_for_withdrawal_at_risk += userJtokensAtRisk;
  UserLiquidation storage user_liquidation = queued_user_liquidations[msg.sender];
  user_liquidation.amount = userJtokens;
  user_liquidation.amount_at_risk = userJtokensAtRisk;
  user_liquidation.timestamp = ABOND.end;
  // with UserLiquidation set, this user address can not buy jTokens until the 2nd step is complete. (for gas efficiency purposes)

  if(block.timestamp >= ABOND.end) {
    // SPECIAL CASE
    // In case ABOND.end is in the past, liquidate immediately
    if(liquidation.price == 0) {
      liquidate(ABOND.end);
    } else {
      owed_dai += user_liquidation.amount * liquidation.price;
      burn(user_liquidation.amount); // burns user's locked tokens reducing the jToken supply
      jtokens_total_queued_for_withdrawal -= user_liquidation.amount;
      jtokens_queued_for_withdrawal_at_risk -= user_liquidation.amount_at_risk;
    }
    return juniorFinishWithdraw();
  }

  return user_liquidation;
}

modifier parseLiquidations {
    // this modifier will be added to all (write) functions.
    // The first tx after a queued liquidation's timestamp will trigger the liquidation
    // reducing the jToken supply, and setting aside owed_dai for withdrawals
    for (uint i = last_queued_liquidation_timestamps_key; i<queued_liquidation_timestamps.length-1; i++){
        if(block.timestamp >= queued_liquidation_timestamps[i]) {
          liquidate(queued_liquidation_timestamps[i]);
          last_queued_liquidation_timestamps_key = i;
        } else {
          break;
        }
    }
    _;
}

function liquidate(timestamp) {
  Liquidation storage liquidation = queued_liquidations[timestamp];
  require(liquidation.amount > 0, "no queued liquidation");
  require(liquidation.price == 0, "already liquidated");

  //recalculate current price (takes into account P&L)
  recalculateJTokenPrice();
  liquidation.price = bbcDAI_to_DAI_ratio;

  owed_dai += liquidation.amount * liquidation.price;
  burn(liquidation.amount); // burns Junior locked tokens reducing the jToken supply
  jtokens_total_queued_for_withdrawal -= liquidation.amount;
  jtokens_queued_for_withdrawal_at_risk -= liquidation.amount_at_risk;
}

function juniorFinishWithdraw() {
  UserLiquidation storage user_liquidation = queued_user_liquidations[msg.sender];
  require(user_liquidation.amount > 0, "No liquidation queued for user");
  require(user_liquidation.timestamp <= block.timestamp, "Lock period is not over");

  Liquidation storage liquidation = queued_liquidations[timestamp];

  owed_dai_to_user = liquidation.price * user_liquidation.amount;

  // remove lock
  user_liquidation.amount = 0;
  user_liquidation.amount_at_risk = 0;
  user_liquidation.timestamp = 0;

  // sell cDAI (or provider's DAI to pay the user)
  buyDAIFromProvider(owed_dai_to_user);

  dai.transfer(msg.sender, owed_dai_to_user);

  owed_dai -= owed_dai_to_user;

  return owed_dai_to_user;
}
```


## Pool overview
![](https://i.imgur.com/lNdoOL8.jpg)


# Fee Structure
On the Senior side, fees are collected after maturity date, when sBonds are redeemed.

On the Junior side, fees are collected on jToken purchases (bbcDAI in the example above).

The percentage of fee that goes to BBDAO treasury is set by the BBDAO.


# Secondary Markets
The Junior Tokens are ERC20 compatible since they are fungible. Secondary markets can easily be created for these (e.g. Uniswap). This will allow jToken holders that need liquidity to exit quickly, probably with a discount.

The Senior BOND tokens (sBOND) are non-fungible (NFTs), but transferrable. One could sell these tokens before their maturity date at a discount to someone who is willing to wait until the end to claim the principle plus the guaranteed reward.

BarnBridge will build a marketplace for selling and buying of senior tokens. The pool is permissionless so others can build marketplaces as well.

# Junior-Side Incentivization
To further incentivize participation by Juniors and to bootstrap the Smart Yield product, c_bbDAI tokens (and other Junior pool tokens) can be locked in our YieldFarming pools for weekly BOND rewards.

The Smart Yield YF pool will accept all Junior Tokens created by BarnBridge protocol. To keep the scale equal, the default `bbcDAI_to_DAI_ratio` value of each pool will be equal to the current price of the underlying asset (1 in case of stablecoins).

